/**
 * @file interfacea_coroutine.h
 * @brief
 * The content of this file and its corresponding .cpp file
 * should be generated by an IDL-to-C++ compiler from an IDL input file (example.idl)
 * with the request to generate "corolib-compatible" functions.
 * Here, the content has been written manually and simplified because
 * no communication-related code is present.
 *
 * @author Johan Vanslembrouck (johan.vanslembrouck@gmail.com)
 */

#ifndef _INTERFACEA_COROUTINE_H_
#define _INTERFACEA_COROUTINE_H_

#include <corolib/print.h>
#include <corolib/commservice.h>
#include <corolib/async_task.h>
#include <corolib/async_operation.h>

using namespace corolib;

#include "corba.h"

using namespace CORBA;

#include "eventqueue.h"

namespace moduleA
{
    class interfaceACo;
    using interfaceACo_ptr = interfaceACo*;
    
    class interfaceACoHandler_impl;
    using interfaceACoHandler_impl_ptr = interfaceACoHandler_impl*;

    struct operation1_result
    {
        CORBA::Double m_inout_val;
        CORBA::Short m_out_val = 0;
        CORBA::Short m_ret_val = 0;
    };

    /**
     * @brief class interfaceACo
     * This class contains the coroutine functions for operation1 in the example.idl
     */
    class interfaceACo : public CommService
    {
    public:
        async_operation<operation1_result> start_operation1(CORBA::Long in_val, CORBA::Double inout_val);

    protected:
        void start_operation1_impl(const int idx, CORBA::Long in_val, CORBA::Double inout_val);
    };

    /**
     * @brief class interfaceACoHandler_impl
     * This class is the equivalent of interfaceAHandler_impl in interfacea.h.
     * The existence of this class avoids the construction of a lambda function
     * as in all other corolib examples.
     * class interfaceACoHandler_impl can be considered to be the replacement
     * of this lambda, because it implements a call operator.
     */
    class interfaceACoHandler_impl : public Handler_impl
    {
    public:
        interfaceACoHandler_impl(interfaceACo_ptr itf = nullptr, int idx = 0)
            : m_itf(itf)
            , m_idx(idx)
        { }
        ~interfaceACoHandler_impl() { }

        void operation1(operation1_result& res);
        void calculate_result(CORBA::Long in_val, CORBA::Double inout_val);

        void operator()() override;

    protected:
        interfaceACo_ptr m_itf;
        int m_idx;

        CORBA::Double m_inout_val = 0.0;
        CORBA::Short m_out_val = 0;
        CORBA::Short m_ret_val = 0;
    };
}

#endif
