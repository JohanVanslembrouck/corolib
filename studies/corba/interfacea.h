/**
 * @file interfacea.h
 * @brief
 * The content of this file and its corresponding .cpp file
 * is usually generated by an IDL-to-C++ compiler from an IDL input file (example.idl).
 * Here, the content has been written manually and simplified because
 * no communication-related code is present.
 * 
 * @author Johan Vanslembrouck (johan.vanslembrouck@gmail.com)
 */

#ifndef _INTERFACEA_H_
#define _INTERFACEA_H_

#include "corba.h"
#include "eventqueue.h"

namespace moduleA
{
    class interfaceAHandler_impl;
    using interfaceAHandler_impl_ptr = interfaceAHandler_impl*;

    /**
     * @brief class interfaceA
     * This is the main interface class generated by an IDL-to-C++ compiler
     * from the interface definition in example.idl.
     */
    class interfaceA
    {
    public:
        // Synchronous operation
        short operation1(CORBA::Long in_val, CORBA::Double& inout_val, CORBA::Short& out_val);

        // Asynchronous operation using callback
        // In practice, this function may be generated only by passing a command-line argument
        // (instructing the generation of callback-specific code) to the IDL-to-C++ compiler.
        void sendc_operation1(interfaceAHandler_impl_ptr handler, CORBA::Long in_val, CORBA::Double inout_val);

        // Asynchronous operation using (non-)blocking polling
        // In practice, both functions may be generated only by passing a command-line argument
        // (instructing the generation of callback-specific code) to the IDL-to-C++ compiler.
        PollerID sendp_operation1(CORBA::Long in_val, CORBA::Double inout_val);
        CORBA::Boolean operation1Poller(PollerID pollerId, CORBA::Boolean blocking,
                                CORBA::Short& ret_val, CORBA::Double& inout_val, CORBA::Short& out_val);
    };

    /**
     * @brief class interfaceAHandler_impl
     * This class is usually only generated when the IDL-to-C++ compiler is asked
     * to generate asynchronous operations with callback.
     * However, in this example, interfaceAHandler_impl is used in the implementation
     * of all three variants (synchronous, asynchronous with callback,
     * asynchronous with (non-)blocking polling).
     * Therefore, this auxiliary class is always present.
     *
     */
    class interfaceAHandler_impl : public Handler_impl
    {
    public:
        interfaceAHandler_impl() { }
        ~interfaceAHandler_impl() { }

        void operation1(CORBA::Short& ret_val, CORBA::Double& inout_val, CORBA::Short& out_val);

        void calculate_result(CORBA::Long in_val, CORBA::Double inout_val);

        void operator()() override
        {
            m_finished = true;
        }

        bool finished() const
        {
            return m_finished;
        }

    protected:
        CORBA::Boolean m_finished = false;

        CORBA::Double m_inout_val = 0.0;
        CORBA::Short m_out_val = 0;
        CORBA::Short m_ret_val = 0;
    };
}

#endif
